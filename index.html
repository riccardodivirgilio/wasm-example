<script src="pdfium.js?v=5407"></script>


<script>

// variables
        let currentPageIndex = 1;
        let pageLoaded = false;
        let moduleLoaded = false;
        let debugMode = false;
        let autoOpenMode = true;
        let doc;
        let FPDF = {};
        let Module = null;

        // pdfium initialization
        Object.assign(FPDF, {
            ANNOT: 0x01, // Set if annotations are to be rendered.
            LCD_TEXT: 0x02, // Set if using text rendering optimized for LCD display.
            NO_NATIVETEXT: 0x04, // Don't use the native text output available on some platforms
            GRAYSCALE: 0x08, // Grayscale output.
            DEBUG_INFO: 0x80, // Set if you want to get some debug info. Please discuss with Foxit first if you need to collect debug info.
            NO_CATCH: 0x100, // Set if you don't want to catch exception.
            RENDER_LIMITEDIMAGECACHE: 0x200, // Limit image cache size.
            RENDER_FORCEHALFTONE: 0x400, // Always use halftone for image stretching.
            PRINTING: 0x800, // Render for printing.
            REVERSE_BYTE_ORDER: 0x10, // Set whether render in a reverse Byte order, this flag only.
            Bitmap_Gray: 1,
            Bitmap_BGR: 2,
            Bitmap_BGRx: 3,
            Bitmap_BGRA: 4,
            LAST_ERROR: { // Last error types
                SUCCESS: 0,
                UNKNOWN: 1,
                FILE: 2,
                FORMAT: 3,
                PASSWORD: 4,
                SECURITY: 5,
                PAGE: 6
            }
        });

        const I8 = Int8Array;
        const I16 = Int16Array;
        const I32 = Int32Array;
        const U8 = Uint8Array;
        const CH = U8;
        const U16 = Uint16Array;
        const U32 = Uint32Array;
        const F32 = Float32Array;
        const F64 = Float64Array;


         const heap = (J, s) => {
            let E;
            switch (J) {
                case Int8Array: E = Module.HEAP8; break;
                case Int16Array: E = Module.HEAP16; break;
                case Int32Array: E = Module.HEAP32; break;
                case Uint8Array: E = Module.HEAPU8; break;
                case Uint16Array: E = Module.HEAPU16; break;
                case Uint32Array: E = Module.HEAPU32; break;
                case Float32Array: E = Module.HEAPF32; break;
                case Float64Array: E = Module.HEAPF64; break;
            }
            const Z = J.BYTES_PER_ELEMENT; const m = Module._malloc(s * Z);
            const a = Array(1 + s); a[0] = ({ s, J, Z, E, m, free: () => Module._free(m) });
            for (let i = 0; i < s; i++) a[i + 1] = ({ p: m + (i * Z), get v() { return E[m / Z + i]; } });
            return a;
        };

        const H = (t, s, d) => f => {
            const [m, ...a] = heap(t, s);
            const v = f(...a.map(x => x.p));

            if (!v) {
                m.free();
                return d;
            }

            const r = a.map(x => x.v);
            m.free();
            return r;
        };





        function initializeFPDF() {
            FPDF.Init = Module.cwrap('PDFium_Init');
            FPDF.RenderPageBitmap = Module.cwrap('FPDF_RenderPageBitmap', '', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);

            FPDF.Bitmap_FillRect = Module.cwrap('FPDFBitmap_FillRect', '', ['number', 'number', 'number', 'number', 'number', 'number']);
            FPDF.Bitmap_CreateEx = Module.cwrap('FPDFBitmap_CreateEx', 'number', ['number', 'number', 'number', 'number', 'number']);
            FPDF.Bitmap_Destroy = Module.cwrap('FPDFBitmap_Destroy', '', ['number']);

            FPDF.LoadPage = Module.cwrap('FPDF_LoadPage', 'number', ['number', 'number']);
            FPDF.ClosePage = Module.cwrap('FPDF_ClosePage', '', ['number']);

            FPDF.LoadMemDocument = Module.cwrap('FPDF_LoadMemDocument', 'number', ['number', 'number', 'string']);
            FPDF.GetPageSizeByIndex = Module.cwrap('FPDF_GetPageSizeByIndex', 'number', ['number', 'number', 'number', 'number']);
            FPDF.GetLastError = Module.cwrap('FPDF_GetLastError', 'number');
            FPDF.GetPageCount = Module.cwrap('FPDF_GetPageCount', 'number', ['number']);
            FPDF.CloseDocument = Module.cwrap('FPDF_CloseDocument', '', ['number']);
            FPDF.DestroyLibrary = Module.cwrap('FPDF_DestroyLibrary');

            
        }





        class Processor {
            constructor(wasmData) {
                this.wasmData = wasmData;
            }

            getPageSize(i = 0, s = 2) {
                return H(F64, 2, [-1, -1])((w, h) => FPDF.GetPageSizeByIndex(this.wasmData.wasm, i, w, h)).map(v => parseInt(v) * s);
            }

            getRender(i = 0, w, h) {


                const heap = Module._malloc(w * h * 4);

                for (let i = 0; i < w * h * 4; i++) {
                    Module.HEAPU8[heap + i] = 0;
                }

                const bmap = FPDF.Bitmap_CreateEx(w, h, FPDF.Bitmap_BGRA, heap, w * 4);
                const page = FPDF.LoadPage(this.wasmData.wasm, i);

                FPDF.Bitmap_FillRect(bmap, 0, 0, w, h, 0xFFFFFFFF);
                FPDF.RenderPageBitmap(bmap, page, 0, 0, w, h, 0, FPDF.REVERSE_BYTE_ORDER | FPDF.ANNOT);
                FPDF.Bitmap_Destroy(bmap);
                FPDF.ClosePage(page);

                return heap;
            }

            getPageRender(n = 0, w, h) {
                let pageRenderPtr = this.getRender(n, w, h);
                let pageRenderData = [];

                for (let v = 0; v < w * h * 4; v++) {
                    pageRenderData.push(Module.HEAPU8[pageRenderPtr + v]);
                }

                Module._free(pageRenderPtr);

                return pageRenderData;
            }

            render(n = 0, canvas, scale, rotation) {
                const [w, h] = this.getPageSize(n, scale, rotation);
                const data = this.getPageRender(n, w, h, rotation);


                canvas.width = w;
                canvas.height = h;

                const x = canvas.getContext('2d');
                const i = x.createImageData(w, h);
                i.data.set(data);
                x.putImageData(i, 0, 0);
            }

            getLastError() {
                let lastError = FPDF.GetLastError();

                switch (lastError) {
                    case FPDF.LAST_ERROR.SUCCESS:
                        return "success";
                        break;
                    case FPDF.LAST_ERROR.UNKNOWN:
                        return "unknown error";
                        break;
                    case FPDF.LAST_ERROR.FILE:
                        return "file not found or could not be opened";
                        break;
                    case FPDF.LAST_ERROR.FORMAT:
                        return "file not in PDF format or corrupted";
                        break;
                    case FPDF.LAST_ERROR.PASSWORD:
                        return "password required or incorrect password";
                        break;
                    case FPDF.LAST_ERROR.SECURITY:
                        return "unsupported security scheme";
                        break;
                    case FPDF.LAST_ERROR.PAGE:
                        return "page not found or content error";
                        break;
                    default:
                        return "unknown error";
                }
            }
        }

        // runtime initialized
        PDFiumModule().then(function (pdfiumModule) {
            Module = pdfiumModule;

            moduleLoaded = true;

            initializeFPDF()

            console.log('load')


            async function loadFileFromURL(url) {
                    let response = await fetch(url);
                    let fileBuffer = await response.arrayBuffer();
                    let fileByteArray = new Uint8Array(fileBuffer);

                    processPDF(fileByteArray);

            }

          async function processPDF(fileByteArray) {
                // html general

                // check file size
                console.log('Getting file size...');

                let fileSize = fileByteArray.length;
                console.log("File size: " + fileSize + " bytes");

                // init library
                console.log('Initializing library...');

                FPDF.Init();

                // load document to memory
                console.log('Loading data to buffer...');

                let wasmBuffer = Module._malloc(fileSize);
                Module.HEAPU8.set(fileByteArray, wasmBuffer);

                // create document
                console.log('Loading document...');


                const wasmData = {
                    wasm: FPDF.LoadMemDocument(wasmBuffer, fileSize, ""),
                    wasmBuffer: wasmBuffer,
                }

                const processor= new Processor(wasmData)



                // check last error
                let lastError = processor.getLastError();
                console.log("Load document state: " + lastError);

                // count page
                console.log('Couting pages...');

                let page_count = FPDF.GetPageCount(wasmData.wasm);


                console.log('Pages: ' + page_count);


                const page_array = []




                for (let x = 0; x < page_count; x++) {

                    console.log('Page ' + (x + 1));


                    let canvas = document.createElement('canvas');
                    processor.render(x, canvas, 3.0, 90);

                    canvas.toBlob(b => {


                      const url = URL.createObjectURL(b)
                      console.log('RENDER', url)

                      var img = document.createElement('img');
                      img.setAttribute('src', url)
                      document.body.appendChild(img);



                    })
                }

                // clean memory
                console.log('Cleaning objects...');



                console.log('Finished');

                Module._free(doc.processor.wasmData.wasmBuffer);

                FPDF.CloseDocument(doc.processor.wasmData.wasm);
                FPDF.DestroyLibrary();


        }


            loadFileFromURL('https://pdf-lib.js.org/assets/dod_character.pdf')

        });

</script>