<script src="pdfium.js?v=5407"></script>


<script>

// variables
let currentPageIndex = 1;
let pageLoaded = false;
let moduleLoaded = false;
let debugMode = false;
let autoOpenMode = true;
let doc;
let FPDF = {};
let Module = null;

// pdfium initialization
Object.assign(FPDF, {
    ANNOT: 0x01, // Set if annotations are to be rendered.
    LCD_TEXT: 0x02, // Set if using text rendering optimized for LCD display.
    NO_NATIVETEXT: 0x04, // Don't use the native text output available on some platforms
    GRAYSCALE: 0x08, // Grayscale output.
    DEBUG_INFO: 0x80, // Set if you want to get some debug info. Please discuss with Foxit first if you need to collect debug info.
    NO_CATCH: 0x100, // Set if you don't want to catch exception.
    RENDER_LIMITEDIMAGECACHE: 0x200, // Limit image cache size.
    RENDER_FORCEHALFTONE: 0x400, // Always use halftone for image stretching.
    PRINTING: 0x800, // Render for printing.
    REVERSE_BYTE_ORDER: 0x10, // Set whether render in a reverse Byte order, this flag only.
    Bitmap_Gray: 1,
    Bitmap_BGR: 2,
    Bitmap_BGRx: 3,
    Bitmap_BGRA: 4,
    LAST_ERROR: { // Last error types
        SUCCESS: 0,
        UNKNOWN: 1,
        FILE: 2,
        FORMAT: 3,
        PASSWORD: 4,
        SECURITY: 5,
        PAGE: 6
    }
});

const I8 = Int8Array;
const I16 = Int16Array;
const I32 = Int32Array;
const U8 = Uint8Array;
const CH = U8;
const U16 = Uint16Array;
const U32 = Uint32Array;
const F32 = Float32Array;
const F64 = Float64Array;


const heap = (J, s) => {
    let E;
    switch (J) {
        case Int8Array:
            E = Module.HEAP8;
            break;
        case Int16Array:
            E = Module.HEAP16;
            break;
        case Int32Array:
            E = Module.HEAP32;
            break;
        case Uint8Array:
            E = Module.HEAPU8;
            break;
        case Uint16Array:
            E = Module.HEAPU16;
            break;
        case Uint32Array:
            E = Module.HEAPU32;
            break;
        case Float32Array:
            E = Module.HEAPF32;
            break;
        case Float64Array:
            E = Module.HEAPF64;
            break;
    }
    const Z = J.BYTES_PER_ELEMENT;
    const m = Module._malloc(s * Z);
    const a = Array(1 + s);
    a[0] = ({
        s,
        J,
        Z,
        E,
        m,
        free: () => Module._free(m)
    });
    for (let i = 0; i < s; i++) a[i + 1] = ({
        p: m + (i * Z),
        get v() {
            return E[m / Z + i];
        }
    });
    return a;
};

const H = (t, s, d) => f => {
    const [m, ...a] = heap(t, s);
    const v = f(...a.map(x => x.p));

    if (!v) {
        m.free();
        return d;
    }

    const r = a.map(x => x.v);
    m.free();
    return r;
};




function initializeFPDF() {
    FPDF.Init = Module.cwrap('PDFium_Init');
    FPDF.RenderPageBitmap = Module.cwrap('FPDF_RenderPageBitmap', '', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number']);

    FPDF.Bitmap_FillRect = Module.cwrap('FPDFBitmap_FillRect', '', ['number', 'number', 'number', 'number', 'number', 'number']);
    FPDF.Bitmap_CreateEx = Module.cwrap('FPDFBitmap_CreateEx', 'number', ['number', 'number', 'number', 'number', 'number']);
    FPDF.Bitmap_Destroy = Module.cwrap('FPDFBitmap_Destroy', '', ['number']);

    FPDF.LoadPage = Module.cwrap('FPDF_LoadPage', 'number', ['number', 'number']);
    FPDF.ClosePage = Module.cwrap('FPDF_ClosePage', '', ['number']);

    FPDF.LoadMemDocument = Module.cwrap('FPDF_LoadMemDocument', 'number', ['number', 'number', 'string']);
    FPDF.GetPageSizeByIndex = Module.cwrap('FPDF_GetPageSizeByIndex', 'number', ['number', 'number', 'number', 'number']);
    FPDF.GetLastError = Module.cwrap('FPDF_GetLastError', 'number');
    FPDF.GetPageCount = Module.cwrap('FPDF_GetPageCount', 'number', ['number']);
    FPDF.CloseDocument = Module.cwrap('FPDF_CloseDocument', '', ['number']);
    FPDF.DestroyLibrary = Module.cwrap('FPDF_DestroyLibrary');

    //FPDF.GetTrimBox = Module.cwrap('FPDFPage_GetTrimBox');

}


function getLastError() {
    let lastError = FPDF.GetLastError();

    switch (lastError) {
        case FPDF.LAST_ERROR.SUCCESS:
            return "success";
            break;
        case FPDF.LAST_ERROR.UNKNOWN:
            return "unknown error";
            break;
        case FPDF.LAST_ERROR.FILE:
            return "file not found or could not be opened";
            break;
        case FPDF.LAST_ERROR.FORMAT:
            return "file not in PDF format or corrupted";
            break;
        case FPDF.LAST_ERROR.PASSWORD:
            return "password required or incorrect password";
            break;
        case FPDF.LAST_ERROR.SECURITY:
            return "unsupported security scheme";
            break;
        case FPDF.LAST_ERROR.PAGE:
            return "page not found or content error";
            break;
        default:
            return "unknown error";
    }
}


class Processor {
    constructor(doc) {
        this.doc = doc;
    }

    getPageSize(i = 0, s = 2) {
        return H(F64, 2, [-1, -1])((w, h) => FPDF.GetPageSizeByIndex(this.doc, i, w, h)).map(v => parseInt(v) * s);
    }


    getPageRender(i = 0, w, h) {

        const pageRenderPtr = Module._malloc(w * h * 4);

        for (let i = 0; i < w * h * 4; i++) {
            Module.HEAPU8[pageRenderPtr + i] = 0;
        }

        const bmap = FPDF.Bitmap_CreateEx(w, h, FPDF.Bitmap_BGRA, pageRenderPtr, w * 4);
        const page = FPDF.LoadPage(this.doc, i);

        FPDF.Bitmap_FillRect(bmap, 0, 0, w, h, 0xFFFFFFFF);
        FPDF.RenderPageBitmap(bmap, page, 0, 0, w, h, 0, FPDF.REVERSE_BYTE_ORDER | FPDF.ANNOT);
        FPDF.Bitmap_Destroy(bmap);
        FPDF.ClosePage(page);


        let raster = [];

        for (let v = 0; v < w * h * 4; v++) {
            raster.push(Module.HEAPU8[pageRenderPtr + v]);
        }

        Module._free(pageRenderPtr);

        return raster;
    }

    render(i = 0, scale = 1.0) {


        
        const [w, h] = this.getPageSize(i, scale);
        const raster = this.getPageRender(i, w, h);

        const canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;

        const context = canvas.getContext('2d');


        //const i = x.createImageData(w, h);
        const image = new ImageData(w, h);

        image.data.set(raster);
        context.putImageData(image, 0, 0);

        return canvas
    }

}

// runtime initialized
PDFiumModule().then(function(pdfiumModule) {
    Module = pdfiumModule;

    moduleLoaded = true;

    initializeFPDF()

    console.log('load')


    async function loadFileFromURL(url) {
        let response = await fetch(url);
        let fileBuffer = await response.arrayBuffer();
        let fileByteArray = new Uint8Array(fileBuffer);

        processPDF(fileByteArray);

    }

    async function processPDF(fileByteArray) {
        // html general

        // init library
        console.log('Initializing library...');

        FPDF.Init();



        console.log("File size: " + fileByteArray.length + " bytes");

        // load document to memory
        console.log('Loading data to buffer...');

        let wasmBuffer = Module._malloc(fileByteArray.length);
        Module.HEAPU8.set(fileByteArray, wasmBuffer);

        // create document
        console.log('Loading document...');

        const doc = FPDF.LoadMemDocument(wasmBuffer, fileByteArray.length, "")


        const processor = new Processor(doc, wasmBuffer)



        // check last error
        let lastError = getLastError();
        console.log("Load document state: " + lastError);

        // count page

        let page_count = FPDF.GetPageCount(doc);


        console.log('Pages: ' + page_count);


        const page_array = []




        for (let x = 0; x < page_count; x++) {

            console.log('Page ' + (x + 1));


            
            processor.render(x, scale = 2).toBlob(b => {


                const url = URL.createObjectURL(b)
                console.log('Page '+(x+1), url)

                var img = document.createElement('img');
                img.setAttribute('src', url)
                document.body.appendChild(img);

            })
        }

        // clean memory
        console.log('Cleaning objects...');




        Module._free(wasmBuffer);

        FPDF.CloseDocument(doc);
        FPDF.DestroyLibrary();
        console.log('Finished');


    }


    loadFileFromURL('https://pdf-lib.js.org/assets/dod_character.pdf')

});

</script>